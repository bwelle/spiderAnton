<!doctype html>
<html lang = "en" >
<head>
<meta charset = "utf-8" >
<meta name = "viewport" content= "width=device-width, initial-scale=1">
<meta name = "description" content = "speed shape geometry" >
<meta name = "keywords" content = "JavaScript,GitHub,FOSS,3D,STEM" >
<meta name = "date" content = "2017-10-31" >
<title>SPEED / Geometry</title>
<style>

	body { font: 12pt monospace; margin: 0 auto; max-width: 800px; }
	a { color: crimson; text-decoration: none; }
	a:hover, a:focus { background-color: yellow; color: #aaa; text-decoration: underline }

	canvas { border: 1px solid black; }
	select { width: 150px; }
	table { border-spacing: 20px; width: 100%; }

	input, input[ type = number ] { width: 50px; }

	input[type=range] { -webkit-appearance: none; -moz-appearance: none; background-color: #ddd; width: 100%; }
	input[type=range]::-moz-range-thumb { background-color: #888; border-radius: 0; width: 10px; }
	input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; background-color: #888; height: 20px; width: 10px; }


	td { text-align: center; }
	.checkbox { text-align: right; }
	.column { display: inline-block; line-height: 30px; width: 150px;}
	.floatright { float: right; }

	#canvasPerspective { position:absolute; right: 100px; top: 50%; }
	#canvasOrtho { position:absolute; left: 100px; top: 50%; }
	#divDimensions, #divDimensions div { left: 0; margin: 20px auto; right: 0; width: 250px; }

	#divInput, #divCalcs { display: inline-block; margin: 0 10px; vertical-align: top; width: 300px; }


</style>
</head>
<body>
<script src = "http://cdn.rawgit.com/mrdoob/three.js/r88/build/three.min.js" ></script>
<script src = "http://cdn.rawgit.com/mrdoob/three.js/r88/examples/js/controls/OrbitControls.js" ></script>

	<div id = "header" >

		<h1 id = "title" >
			<a href="./index.html" target=_top >&#x2302;</a> &raquo;
			<a href="" >Site Content</a>
			<a href=https://github.com/ladybug-tools/spider/blob/master/sandbox/speed-specification/shape-geometry.html target="_top"><img src="https://status.github.com/images/invertocat.png" height=25 ></a>

		</h1>

		<h2>Geometry 2.1</h2>

	</div>

	<div id = "divInput" >

		<table>

			<tr>
				<td>Building Area</td><td># of Floors</td><td>Floor Area</td><td>Floor Height</td><td># of Footprint Shapes</td>
			</tr>

			<tr>
				<td><input type=number id=inpArea step=50 onchange=changeBuildingArea(); ></td>
				<td><input type=number id=inpFloors step=1 onchange=changeNumFloors();></td>
				<td><output type=number id=outFloorArea ></output></td>
				<td><input type=number id=inpHeight onChange=updateShape(); ></td>
				<td><input type=number id=inpShapeCount ></td>
			</tr>

		</table>

		<table>

			<tr>
				<td>Footprint Shape</td><td>Massing Generator</td><td>Perimeter Depth</td><td>Orientation</td>
			</tr>

			<tr>
				<td><select id=selShape size=4 onchange=changeBuildingShape(); ></select></td><td><select id=selMassing ></select></td><td><input type=number id=inpPerimeterDepth ></td><td><input type=number id=inpOrientation oninput=updateShape(); ></td>
			</tr>

		</table>

		<div id=divDimensions >

			<div>Footprint dimensions</div>

			<div>
				Length <output id=outLength class=floatright ></output>
				<input type=range step=0.5 id=inpLength class="slider" oninput=changeLengthSlider(); >
				<input type="text" id="lengthSlider" value="">
			</div>

			<div>
				Width <output id=outWidth class=floatright ></output>
				<input type=range step=0.5 id=inpWidth class="slider" oninput=changeWidthSlider(); >
				<input type="text" id="widthSlider" value="">
			</div>

			<div id=divThickness >
				Thickness <output id=outThickness class=floatright ></output>
			</div>

			<div id=divValidation ></div>

		</div>

	</div>

	<canvas id="canvasPerspective" height=1 width=1 ></canvas>

	<canvas id="canvasOrtho"  height=1 width=1 ></canvas>

<script>


	let theBuilding;

	let gridHelper, axesHelper;
	let renderer, camera, controls, scene;

	let lightAmbient, lightDirectional, cameraHelper, axisHelper;

	var previousinpAreaValue,previousinpFloorsValue,previousWidthValue

	var thickness

	var v = function( x, y, z ){ return new THREE.Vector3( x, y, z ); };
	var v2 = function( x, y ){ return new THREE.Vector2( x, y ); };
	var pi = Math.PI;
	const d2r = pi / 180, r2d = 180 /pi;

	const buildingShapes =
	{
		"Lshape":0,
		"Hshape":1,
		"Tshape":2,
		"Boxshape":3
	};

	/// Helper functions

	function stringOfBuildingShapeToBuildingShapeEnum(selectedShapeType){
		if (selectedShapeType === "L-Shape")
		{
			return buildingShapes.Lshape
		}
		else if (selectedShapeType === "H-Shape")
		{
			return buildingShapes.Hshape
		}
		else if (selectedShapeType === "T-Shape")
		{
			return buildingShapes.Tshape
		}
		else if (selectedShapeType === "Box-Shape")
		{
			return buildingShapes.Boxshape
		}
		else {
			throw new Error('Cannot convert string '+string+ ' to building shape enum!!')
		}
	}

	init();

	function init() {

		initThreejs();

		initInputFields();

		updateShape();

		animate();

	}

	function initInputFields(){
		/// Assume that we start on L-shape with a building area of 5000 and 1 floor

		inpArea.value = 5000;
		previousinpAreaValue = 5000;

		inpFloors.min = 1;
		inpFloors.max = 20;
		inpFloors.value = 1;

		previousinpFloorsValue = 1;

		inpHeight.min = 8;
		inpHeight.max = 20;
		inpHeight.value = 10;

		inpShapeCount.min = 1;
		inpShapeCount.max = 10;
		inpShapeCount.value = 3;

		selShape.innerHTML =
			'<option>Box-Shape</option>' +
			'<option>L-Shape</option>' +
			'<option>T-Shape</option>' +
			'<option>H-Shape</option>' +
		'';

		selShape.selectedIndex = 1;

		selMassing.innerHTML =
			'<option>Generator 1</option>' +
			'<option>Generator 2</option>' +
			'<option>Generator 3</option>' +
		'';

		inpPerimeterDepth.min = 10;
		inpPerimeterDepth.max = 20;
		inpPerimeterDepth.value = 3;

		inpOrientation.min = -90;
		inpOrientation.max = 90;

		changeBuildingShape(stringOfBuildingShapeToBuildingShapeEnum(selShape.value))

		}

		function updateTextInput(val,elementID)
		{
			//console.log(val)
			document.getElementById(elementID).value=val;
		}

		function updateThicknessLshape()
		{
			buildingArea = parseFloat(inpArea.value)

			numFloors = parseInt(inpFloors.value)

			floorArea = buildingArea/numFloors

			a = (parseFloat(inpWidth.value)+parseFloat(inpLength.value))/2

			b = Math.sqrt(Math.pow(a,2)-floorArea)

			thickness = a-b
		}

		/// Implemented using the table in Geometry Logic map
		function changeBuildingShape(buildingShape = selShape.value)
		{
			// Strangely in slider the values are stored as strings we need to make sure that they are parsed as numbers before used

			floorArea = parseFloat(inpArea.value)/parseInt(inpFloors.value)

			switch (buildingShape)
			{
				case buildingShapes.Lshape:

						inpLength.value = Math.sqrt(floorArea*1.8)

						inpLength.min = 2/3*Math.sqrt(floorArea*1.8);

						inpLength.max = 2*Math.sqrt(floorArea*1.8);

						/// Width is y
						inpWidth.value = Math.sqrt(floorArea*1.8)

						previousWidthValue = parseFloat(inpWidth.value)

						inpWidth.min = floorArea/parseFloat(inpLength.value)

						inpWidth.max = 10*(floorArea/parseFloat(inpWidth.value)) - 0.9*parseFloat(inpWidth.value)

						updateThicknessLshape()

						console.log("Building Shape successfully changed to L-shape")
					break;
				default:
					throw new Error('Building type enum does not exist!')
			}

			updateTextInput(inpLength.value,"lengthSlider")

			updateTextInput(inpWidth.value,'widthSlider')

			updateShape()

		}

		function changeNumFloors(buildingShape = stringOfBuildingShapeToBuildingShapeEnum(selShape.value))
		{

			// Strangely in slider the values are stored as strings we need to make sure that they are parsed as numbers before used

			floorArea = parseFloat(inpArea.value)/parseInt(inpFloors.value)

			numFloors = parseInt(inpFloors.value)

			switch (buildingShape)
			{
				case buildingShapes.Lshape:
					/// Length is x
					inpLength.max = 2*Math.sqrt(floorArea*1.8);

					inpLength.min = 2/3*Math.sqrt(floorArea*1.8);

					// create factor change on the length
					inpLength.value = Math.sqrt(previousinpFloorsValue/parseInt(numFloors))*parseFloat(inpLength.value)

					/// Width is y
					inpWidth.max = 10*(floorArea/parseFloat(inpLength.value))-0.9*parseFloat(inpLength.value)

					inpWidth.min = floorArea/parseFloat(inpLength.value)

					inpWidth.value = Math.sqrt(previousinpFloorsValue/parseInt(numFloors))*parseFloat(inpWidth.value)

					updateThicknessLshape()
					break;

				case buildingShapes.Hshape:

					inpLength.max = lengthMax

					inpLength.min = lengthMin

					inpWidth.max = widthMax

					inpWidth.min = widthMin

					break;
				case buildingShapes.Tshape:

					inpLength.max = lengthMax

					inpLength.min = lengthMin

					inpWidth.max = widthMax

					inpWidth.min = widthMin

					break;
				case buildingShapes.Boxshape:

					inpLength.max = lengthMax

					inpLength.min = lengthMin

					inpWidth.max = widthMax

					inpWidth.min = widthMin

					break;
				default:
					throw new Error('Building type enum does not exist!')
			}
			// Update the previous value
			previousinpFloorsValue = parseInt(inpFloors.value)

			updateTextInput(inpLength.value,"lengthSlider")

			updateTextInput(inpWidth.value,'widthSlider')

			updateShape()

		}

		function changeBuildingArea(buildingShape = stringOfBuildingShapeToBuildingShapeEnum(selShape.value))
		{
			buildingArea = parseFloat(inpArea.value)

			numFloors = parseInt(inpFloors.value)

			floorArea = buildingArea/numFloors

			switch (buildingShape)
			{
				case buildingShapes.Lshape:
					/// Length is x
					inpLength.max = 2*Math.sqrt(floorArea*1.8);

					inpLength.min = 2/3*Math.sqrt(floorArea*1.8);

					// Must be by floor area
					// create factor change on the length
					inpLength.value = Math.sqrt(floorArea/previousinpAreaValue)*parseFloat(inpLength.value)

					/// Width is y
					inpWidth.max = 10*(floorArea/parseFloat(inpLength.value))-0.9*parseFloat(inpLength.value)

					inpWidth.min = floorArea/parseFloat(inpLength.value)

					inpWidth.value = Math.sqrt(floorArea/previousinpAreaValue)*parseFloat(inpWidth.value)
					// User will never set the thickness themselves
					updateThicknessLshape()
					break;

				case buildingShapes.Hshape:

					inpLength.max = lengthMax

					inpLength.min = lengthMin

					inpWidth.max = widthMax

					inpWidth.min = widthMin

					break;
				case buildingShapes.Tshape:

					inpLength.max = lengthMax

					inpLength.min = lengthMin

					inpWidth.max = widthMax

					inpWidth.min = widthMin

					break;
				case buildingShapes.Boxshape:

					inpLength.max = lengthMax

					inpLength.min = lengthMin

					inpWidth.max = widthMax

					inpWidth.min = widthMin

					break;
				default:
					throw new Error('Building type enum does not exist!')
			}
			// Update the previous value
			previousinpAreaValue = inpArea.value

			updateTextInput(inpLength.value,"lengthSlider")

			updateTextInput(inpWidth.value,'widthSlider')

			updateShape()

		}

		function changeLengthSlider(buildingShape = stringOfBuildingShapeToBuildingShapeEnum(selShape.value))
		{

			floorArea = parseFloat(inpArea.value)/parseInt(inpFloors.value)

			ratio = (previousWidthValue-parseFloat(inpWidth.min))/(parseFloat(inpWidth.max)-parseFloat(inpWidth.min))

			switch (buildingShape)
			{
				case buildingShapes.Lshape:

					inpWidth.max = 10*(floorArea/parseFloat(inpLength.value))-0.9*parseFloat(inpLength.value)

					inpWidth.min = floorArea/parseFloat(inpLength.value)

					inpWidth.value = ratio*(parseFloat(inpWidth.max)-parseFloat(inpWidth.min))+parseFloat(inpWidth.min)

					updateThicknessLshape()

					// Update previousWidthValue
					previousWidthValue = inpWidth.value

					break;
				case buildingShapes.Hshape:

					//thickness = (inpWidth.value+inpLength.value)/2 - Math.sqrt(((inpWidth.value+inpLength.value)/2)^2-floorArea)
					break;
				case buildingShapes.Tshape:

					//thickness = (inpWidth.value+inpLength.value)/2 - Math.sqrt(((inpWidth.value+inpLength.value)/2)^2-floorArea)
					break;
				case buildingShapes.Boxshape:

					//thickness = thickness = (parseFloat(inpWidth.value)+parseFloat(inpLength.value))/2 - Math.sqrt(((parseFloat(inpWidth.value)+parseFloat(inpLength.value))/2)^2-floorArea)
					break;
				default:
					throw new Error('Building type enum does not exist!')
			}

			updateTextInput(inpLength.value,"lengthSlider")

			updateTextInput(inpWidth.value,'widthSlider')

			updateShape()
		}

		function changeWidthSlider(buildingShape = stringOfBuildingShapeToBuildingShapeEnum(selShape.value))
		{
			floorArea = parseFloat(inpArea.value)/parseInt(inpFloors.value)

			switch (buildingShape)
			{
				// Re-calculate thickness
				case buildingShapes.Lshape:

					inpWidth.max = 10*(floorArea/parseFloat(inpLength.value))-0.9*parseFloat(inpLength.value)

					inpWidth.min = floorArea/parseFloat(inpLength.value)

					updateThicknessLshape()

					break;
				case buildingShapes.Hshape:

					thickness = (inpWidth.value+inpLength.value)/2 - Math.sqrt(((inpWidth.value+inpLength.value)/2)^2-floorArea)
					break;
				case buildingShapes.Tshape:

					thickness = (inpWidth.value+inpLength.value)/2 - Math.sqrt(((inpWidth.value+inpLength.value)/2)^2-floorArea)
					break;
				case buildingShapes.Boxshape:

					thickness = (inpWidth.value+inpLength.value)/2 - Math.sqrt(((inpWidth.value+inpLength.value)/2)^2-floorArea)
					break;
				default:
					throw new Error('Building type enum does not exist!')
		}

		updateTextInput(inpLength.value,"lengthSlider")

		updateTextInput(inpWidth.value,'widthSlider')

		updateShape()
	}

	function initThreejs() {

		width = 300;
		height = 300;

		renderer = new THREE.WebGLRenderer( { alpha: 1, antialias: true }  );
		renderer.setClearColor( 0xffffff, 1 );
		renderer.setSize( width, height );
		renderer.shadowMap.enabled = true;

		context1 = canvasPerspective.getContext( '2d' );
		context2 = canvasOrtho.getContext( '2d' );

		camera1 = new THREE.PerspectiveCamera( 40, width / height, 1, 1000 );
		camera1.position.set( -80, -250, 200 );
		camera1.up.set( 0, 0, 1 );

		controls = new THREE.OrbitControls( camera1, canvasPerspective );
		controls.maxDistance = 600;

		camera2 = new THREE.OrthographicCamera( width / -3, width / 3, height / 3, height / - 3, 1, 1000 );
		camera2.position.set( 0, 0, 100 );
		camera2.up.set( 0, 0, 1 );

		controls2 = new THREE.OrbitControls( camera2, canvasOrtho );

		scene = new THREE.Scene();

		lightAmbient = new THREE.AmbientLight( 0x444444 );
		scene.add( lightAmbient );

		const size = 100
		lightDirectional = new THREE.DirectionalLight( 0xffeedd );
		lightDirectional.position.set( -size, size, size );
		lightDirectional.shadow.camera.scale.set( 13, 15, 0.5 );
		lightDirectional.castShadow = true;
		scene.add( lightDirectional );

		addHelpers();
	}

	function addHelpers( size = 200 ) {

		scene.remove( gridHelper, axesHelper );

		gridHelper = new THREE.GridHelper( size, size / 10 );
		gridHelper.rotation.x = 0.5 * Math.PI;

		axesHelper = new THREE.AxesHelper( size * 0.1 );
		axesHelper.position.set( -0.5 * size, -0.5 * size, 15 );
		axesHelper.material.linewidth = 20;

		scene.add( gridHelper, axesHelper );

	}

	function updateShape() {

		outThickness.value = thickness

		divValidation.innerHTML =
			'<h3>Results from geometry logic</h3>' +
			'building Area: ' + inpArea.value + '<br>' +
			'number of Floors: ' + inpFloors.value + '<br>' +
			'floor Area: ' + inpArea.value/inpFloors.value + '<br>' +
			'<br>' +
			'<b>Length</b><br>' +
			'length: ' + inpLength.value + '<br>' +
			'lengthMin: ' + inpLength.min + '<br>' +
			'lengthMax: ' + inpLength.max + '<br>' +
			//			'lengthRange(): ' + lengthRange + '<br>' +
			'<br>' +
			'<b>Width</b><br>' +
			'width: ' + inpWidth.value + '<br>' +
			'widthMin: ' + inpWidth.min + '<br>' +
			'widthMax: ' + inpWidth.max + '<br>' +
//			'widthRange(): ' + widthRange + '<br>' +
			'<br>' +
		'';

		// theBuilding = {}
		//
		// const pathFunctions = [ getPathBox, getPathL, getPathT , getPathH ];
		//
		// theBuilding.storeyHeight = parseInt( inpHeight.value, 10 );
		// theBuilding.orientation = parseInt( inpOrientation.value, 10 );
		//
		// let mesh = theBuilding.mesh;
		//
		// scene.remove( theBuilding.mesh );
		//
		// const pathFunction = pathFunctions[ selShape.selectedIndex ];
		//
		// theBuilding.path = pathFunction();
		//
		// console.log(theBuilding.path)
		//
		// theBuilding.shape = selShape[ selShape.selectedIndex ];
		// theBuilding.mesh = createShape();
		//
		// theBuilding.mesh.name = 'theBuilding';
		// theBuilding.mesh.position.z =  0.5 * theBuilding.storeyHeight * theBuilding.storeys;
		// theBuilding.mesh.rotation.z = - d2r * theBuilding.orientation;
		//
		// scene.add( theBuilding.mesh );
		//
		// outFloorArea.value = Math.round( theBuilding.area / theBuilding.storeys ).toLocaleString();
		// outLength.value = theBuilding.length.toFixed();
		// outWidth.value = theBuilding.width.toFixed();
		// outThickness.value = theBuilding.thickness.toFixed();

	}

	function getPathBox() {

		let area = theBuilding.area;
		let len = theBuilding.length;
		let wid = theBuilding.width;
		let flr = theBuilding.storeys ;

		if ( area !== parseInt( inpArea.value, 10 ) || flr !== parseInt( inpFloors.value, 10 ) ) {

			const areaNew = parseInt( inpArea.value, 10 )
			const flrNew = parseInt( inpFloors.value, 10 );
			const areaTemp = area * flrNew / flr;

			const ratio = Math.sqrt( area / areaTemp );

			len = Math.round( ratio * len );
			wid = areaNew / ( len * flrNew );
			flr = flrNew;

			theBuilding.area = areaNew;
			theBuilding.storeys = flrNew;
			theBuilding.length = len;
			theBuilding.width = wid;

			inpLength.value = len;
			inpWidth.value = wid;

		} else if ( len !== parseInt( inpLength.value, 10 ) ) {

			len = parseInt( inpLength.value, 10 );
			wid = area / ( len * flr );

			theBuilding.length = len;
			theBuilding.width = wid;

			inpWidth.value = wid;

		} else if ( wid !== parseInt( inpWidth.value, 10 ) ) {

			wid = parseInt( inpWidth.value, 10 );
			len = area / ( wid * flr );

			theBuilding.length = len;
			theBuilding.width = wid;

			inpLength.value = len;

		}

		const pathBox = [ v2( len, 0 ), v2( 0, 0 ), v2( 0, wid ), v2( len, wid ), v2( len, 0 ) ];

		// divValidation.innerHTML =
		// 	'<p>Validations</p>' +
		// 	'<p>Calculated Area: ' + flr * ( len * wid ) + '<p>' +
		// 	'<p>[flr * ( len * wid )]</p>' +
		// 	'<p>Frame: ' + renderer.info.render.frame + '</p>' +
		// '';


		divThickness.style.display = 'none';

		//console.log( 'theBuilding', theBuilding );

		return pathBox;

	}

	function getPathL() {

		let area = theBuilding.area;

		let flr = theBuilding.storeys;

		let len = theBuilding.length;

		let wid = theBuilding.width;
		let thk = theBuilding.thickness;

		if ( theBuilding.lengthInit === 0 ) {

			inpLength.value = 120;

		}

		if ( area !== parseInt( inpArea.value, 10 ) || flr !== parseInt( inpFloors.value, 10 ) ) {

			const areaNew = parseInt( inpArea.value, 10 )
			const flrNew = parseInt( inpFloors.value, 10 );
			const areaTemp = area * flrNew / flr;
			const ratio = Math.sqrt( area / areaTemp );

			flr = flrNew;
			len = Math.round( ratio * len );
			wid = ( ( area - thk * len ) / thk + thk ) / flr;

			theBuilding.area = areaNew;
			theBuilding.storeys = flr;
			theBuilding.length = theBuilding.lengthInit = len;
			theBuilding.width = wid;

			inpLength.value = len;
			inpWidth.value = wid;

		} else if ( len !== parseInt( inpLength.value, 10 ) ) {

			len = parseInt( inpLength.value, 10 );
			wid = ( ( area - thk * len ) / thk + thk ) / flr;
			theBuilding.length = theBuilding.lengthInit = len;
			theBuilding.width = wid;
			inpWidth.value = wid;

		} else if ( wid !== parseInt( inpWidth.value, 10 ) ) {

			wid = parseInt( inpWidth.value, 10 );
			len = ( area - thk * ( wid - thk ) ) / ( thk * flr );

			theBuilding.length = theBuilding.lengthInit = len;
			theBuilding.width = wid;

			inpLength.value = len;

		}

		const pathL = [
			v2( len, 0 ),
			v2( 0, 0 ),
			v2( 0, wid ),
			v2( thk, wid ),
			v2( thk, thk ),
			v2( len, thk ),
			v2( len, 0 )
		];


		// divValidation.innerHTML =
		// 	'<p>Validations</p>' +
		// 	'<p>Calculated Area: ' + flr * ( thk * len + thk * ( wid - thk ) ) + '<p>' +
		// 	'<p>[ flr * ( thk * len + thk * ( wid - thk ) ) ]</p>' +
		// 	'<p>Frame: ' + renderer.info.render.frame + '</p>' +
		// '';

		divThickness.style.display = '';

		return pathL;

	}

	function getPathT() {

		let area = theBuilding.area;
		let flr = theBuilding.storeys;
		let len = theBuilding.length;
		let wid = theBuilding.width;
		let thk = theBuilding.thickness;

		if ( theBuilding.lengthInit === 0 ) {

			inpLength.value = 120;

		}

		if ( area !== parseInt( inpArea.value, 10 ) || flr !== parseInt( inpFloors.value, 10 ) ) {

			const areaNew = parseInt( inpArea.value, 10 )
			const flrNew = parseInt( inpFloors.value, 10 );
			const areaTemp = area * flrNew / flr;
			const ratio = Math.sqrt( area / areaTemp );

			flr = flrNew;
			len = Math.round( ratio * len );
			wid = ( ( area - thk * len ) / thk + thk ) / flr;

			theBuilding.area = areaNew;
			theBuilding.storeys = flr;
			theBuilding.lengthInit = theBuilding.length = len;
			theBuilding.width = wid;

			inpLength.value = len;
			inpWidth.value = wid;

		} else if ( len !== parseInt( inpLength.value, 10 ) ) {

			len = parseInt( inpLength.value, 10 );
			wid = ( ( area - thk * len ) / thk + thk ) / flr;
			theBuilding.lengthInit = theBuilding.length = len;
			theBuilding.width = wid;

			inpWidth.value = wid;

		} else if ( wid !== parseInt( inpWidth.value, 10 ) ) {

			wid = parseInt( inpWidth.value, 10 );
			len = ( area - thk * ( wid - thk ) ) / ( thk * flr );

			theBuilding.lengthInit = theBuilding.length = len;
			theBuilding.width = wid;

			inpLength.value = len;

		}

		const pathT = [
			v2( len, 0 ),
			v2( 0, 0 ),
			v2( 0, thk ),
			v2( 0.5 * ( len - thk ), thk ),
			v2( 0.5 * ( len - thk ), wid ),
			v2( len - 0.5 * ( len - thk ), wid ),
			v2( len - 0.5 * ( len - thk ), thk ),
			v2( len, thk ),
			v2( len, 0 )
		];

		// divValidation.innerHTML =
		// 	'<p>Validations T Shape</p>' +
		// 	'<p>Calculated Area: ' + flr * ( thk * len + thk * ( wid - thk ) ) + '<p>' +
		// 	'<p>[ flr * ( thk * len + thk * ( wid - thk ) ) ]</p>' +
		// 	'<p>Frame: ' + renderer.info.render.frame + '</p>' +
		// '';

		divThickness.style.display = '';

		return pathT;

	}

	function getPathH() {

		let area = theBuilding.area;
		let flr = theBuilding.storeys;
		const flrNew = parseInt( inpFloors.value, 10 );
		let len = theBuilding.length;
		let wid = theBuilding.width;
		let thk = theBuilding.thickness;

		if ( theBuilding.lengthInit === 0 ) {

			inpLength.value = 120;

		}

		if ( area !== parseInt( inpArea.value, 10 ) || flr !== parseInt( inpFloors.value, 10 ) ) {

			const areaNew = parseInt( inpArea.value, 10 );
			const areaTemp = area * flrNew / flr;
			const ratio = Math.sqrt( area / areaTemp );

			len = Math.round( ratio * len );
			wid =  ( area - thk * ( len - 2 * thk ) ) / ( 2 * thk * flrNew );

			theBuilding.area = areaNew;
			theBuilding.storeys = flr = flrNew;
			theBuilding.lengthInit = theBuilding.length = len;
			theBuilding.width = wid;

			inpLength.value = len;
			inpWidth.value = wid;

		} else if ( len !== parseInt( inpLength.value, 10 ) ) {

			len = parseInt( inpLength.value, 10 );
			wid = ( area - thk * ( len - 2 * thk ) ) / ( 2 * thk * flr );
			theBuilding.lengthInit = theBuilding.length = len;
			theBuilding.width = wid;

			inpWidth.value = wid;

		} else if ( wid !== parseInt( inpWidth.value, 10 ) ) {

			wid = parseInt( inpWidth.value, 10 );
			len = ( ( area - thk * wid ) / thk + 2 * thk ) / flr;

			theBuilding.lengthInit = theBuilding.length = len;
			theBuilding.width = wid;

			inpLength.value = len;

		}

		const pathH = [
			v2( len - thk, 0.5 * ( wid - thk ) ),
			v2( thk, 0.5 * ( wid - thk ) ),
			v2( thk, 0 ),
			v2( 0, 0 ),
			v2( 0, wid ),
			v2( thk, wid ),
			v2( thk, wid - 0.5 * ( wid - thk ) ),
			v2( len - thk, wid - 0.5 * ( wid - thk ) ),
			v2( len - thk, wid ),
			v2( len, wid ),
			v2( len, 0 ),
			v2( len - thk, 0 ),
			v2( len - thk, 0.5 * ( wid - thk ) )
		];

		// divValidation.innerHTML =
		// 	'<p>Valibations - H Shape</p>' +
		// 	'<p>Calculated Area: ' + ( flr * ( 2 * thk * wid ) + thk * ( len - 2 * thk ) ) + '</p>' +
		// 	'<p>[ ( flr * ( 2 * thk * wid ) + thk * ( len - 2 * thk ) ) ]</p>' +
		// 	'<p>Frame: ' + renderer.info.render.frame + '</p>' +
		// '';

		divThickness.style.display = '';

		return pathH;

	}

	function createShape() {

		let shape;

		shape = new THREE.Shape( theBuilding.path );
		const amount = theBuilding.storeyHeight * theBuilding.storeys;

		geometry = new THREE.ExtrudeGeometry( shape, { bevelEnabled: false, amount: amount } );
		geometry.center();

		const material = new THREE.MeshPhongMaterial();
		const mesh = new THREE.Mesh( geometry, material );

		const edgesGeometry = new THREE.EdgesGeometry( geometry );
		const meshEdges = new THREE.LineSegments( edgesGeometry, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
		mesh.add( meshEdges );

		return mesh;

	}

	function animate() {

		requestAnimationFrame( animate );

		renderer.autoClear = true;

		controls.update();
		renderer.render( scene, camera1 );
		context1.drawImage( renderer.domElement, 0, 0 );

		controls2.update();
		renderer.render( scene, camera2 );
		context2.drawImage( renderer.domElement, 0, 0 );

	}

</script>
</body>
</html>
